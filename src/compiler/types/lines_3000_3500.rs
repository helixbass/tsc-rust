#![allow(non_upper_case_globals)]

use std::cell::Cell;
use std::rc::Rc;

use super::{
    BaseNamedDeclaration, BaseNode, BaseSignatureDeclaration, HasExpressionInterface,
    HasIsTypeOnlyInterface, HasTypeInterface, NamedDeclarationInterface, Node, NodeArray,
    SyntaxKind, TextRange,
};
use local_macros::ast_type;

#[derive(Debug)]
#[ast_type]
pub struct ExternalModuleReference {
    _node: BaseNode,
    pub expression: Rc<Node /*Expression*/>,
}

impl ExternalModuleReference {
    pub fn new(base_node: BaseNode, expression: Rc<Node>) -> Self {
        Self {
            _node: base_node,
            expression,
        }
    }
}

impl HasExpressionInterface for ExternalModuleReference {
    fn expression(&self) -> Rc<Node> {
        self.expression.clone()
    }
}

#[derive(Debug)]
#[ast_type]
pub struct ImportDeclaration {
    _node: BaseNode,
    pub import_clause: Option<Rc<Node /*ImportClause*/>>,
    pub module_specifier: Rc<Node /*Expression*/>,
    pub assert_clause: Option<Rc<Node /*AssertClause*/>>,
}

impl ImportDeclaration {
    pub fn new(
        base_node: BaseNode,
        import_clause: Option<Rc<Node>>,
        module_specifier: Rc<Node>,
        assert_clause: Option<Rc<Node>>,
    ) -> Self {
        Self {
            _node: base_node,
            import_clause,
            module_specifier,
            assert_clause,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct ImportClause {
    _node: BaseNode,
    pub is_type_only: bool,
    pub name: Option<Rc<Node /*Identifier*/>>,
    pub named_bindings: Option<Rc<Node /*NamedImportBindings*/>>,
}

impl ImportClause {
    pub fn new(
        base_node: BaseNode,
        is_type_only: bool,
        name: Option<Rc<Node>>,
        named_bindings: Option<Rc<Node>>,
    ) -> Self {
        Self {
            _node: base_node,
            is_type_only,
            name,
            named_bindings,
        }
    }
}

impl NamedDeclarationInterface for ImportClause {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        self.name.clone()
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone().unwrap()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = Some(name);
    }
}

impl HasIsTypeOnlyInterface for ImportClause {
    fn is_type_only(&self) -> bool {
        self.is_type_only
    }
}

#[derive(Debug)]
#[ast_type]
pub struct AssertEntry {
    _node: BaseNode,
    pub name: Rc<Node /*AssertionKey*/>,
    pub value: Rc<Node /*StringLiteral*/>,
}

impl AssertEntry {
    pub fn new(base_node: BaseNode, name: Rc<Node>, value: Rc<Node /*StringLiteral*/>) -> Self {
        Self {
            _node: base_node,
            name,
            value,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct AssertClause {
    _node: BaseNode,
    pub elements: NodeArray, /*<AssertEntry>*/
    pub multi_line: Option<bool>,
}

impl AssertClause {
    pub fn new(base_node: BaseNode, elements: NodeArray, multi_line: Option<bool>) -> Self {
        Self {
            _node: base_node,
            elements,
            multi_line,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct NamespaceImport {
    _node: BaseNode,
    pub name: Rc<Node /*Identifier*/>,
}

impl NamespaceImport {
    pub fn new(base_node: BaseNode, name: Rc<Node /*Identifier*/>) -> Self {
        Self {
            _node: base_node,
            name,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct NamespaceExport {
    _node: BaseNode,
    pub name: Rc<Node /*Identifier*/>,
}

impl NamespaceExport {
    pub fn new(base_node: BaseNode, name: Rc<Node /*Identifier*/>) -> Self {
        Self {
            _node: base_node,
            name,
        }
    }
}

#[derive(Debug)]
#[ast_type(interfaces = "NamedDeclarationInterface")]
pub struct NamespaceExportDeclaration {
    _named_declaration: BaseNamedDeclaration,
}

impl NamespaceExportDeclaration {
    pub fn new(base_named_declaration: BaseNamedDeclaration) -> Self {
        Self {
            _named_declaration: base_named_declaration,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct ExportDeclaration {
    _node: BaseNode,
    pub is_type_only: bool,
    pub export_clause: Option<Rc<Node /*NamedExportBindings*/>>,
    pub module_specifier: Option<Rc<Node /*Expression*/>>,
    pub assert_clause: Option<Rc<Node /*AssertClause*/>>,
}

impl ExportDeclaration {
    pub fn new(
        base_node: BaseNode,
        is_type_only: bool,
        export_clause: Option<Rc<Node>>,
        module_specifier: Option<Rc<Node>>,
        assert_clause: Option<Rc<Node>>,
    ) -> Self {
        Self {
            _node: base_node,
            is_type_only,
            export_clause,
            module_specifier,
            assert_clause,
        }
    }
}

impl HasIsTypeOnlyInterface for ExportDeclaration {
    fn is_type_only(&self) -> bool {
        self.is_type_only
    }
}

#[derive(Debug)]
#[ast_type]
pub struct NamedImports {
    _node: BaseNode,
    pub elements: NodeArray, /*<ImportSpecifier>*/
}

impl NamedImports {
    pub fn new(base_node: BaseNode, elements: NodeArray) -> Self {
        Self {
            _node: base_node,
            elements,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct NamedExports {
    _node: BaseNode,
    pub elements: NodeArray, /*<ExportSpecifier>*/
}

impl NamedExports {
    pub fn new(base_node: BaseNode, elements: NodeArray) -> Self {
        Self {
            _node: base_node,
            elements,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct ImportSpecifier {
    _node: BaseNode,
    pub property_name: Option<Rc<Node /*Identifier*/>>,
    pub name: Rc<Node /*Identifier*/>,
    pub is_type_only: bool,
}

impl ImportSpecifier {
    pub fn new(
        base_node: BaseNode,
        is_type_only: bool,
        property_name: Option<Rc<Node>>,
        name: Rc<Node>,
    ) -> Self {
        Self {
            _node: base_node,
            property_name,
            name,
            is_type_only,
        }
    }
}

impl NamedDeclarationInterface for ImportSpecifier {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        Some(self.name.clone())
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = name;
    }
}

impl HasIsTypeOnlyInterface for ImportSpecifier {
    fn is_type_only(&self) -> bool {
        self.is_type_only
    }
}

#[derive(Debug)]
#[ast_type]
pub struct ExportSpecifier {
    _node: BaseNode,
    pub is_type_only: bool,
    pub property_name: Option<Rc<Node /*Identifier*/>>,
    pub name: Rc<Node /*Identifier*/>,
}

impl ExportSpecifier {
    pub fn new(
        base_node: BaseNode,
        is_type_only: bool,
        property_name: Option<Rc<Node>>,
        name: Rc<Node>,
    ) -> Self {
        Self {
            _node: base_node,
            is_type_only,
            property_name,
            name,
        }
    }
}

impl NamedDeclarationInterface for ExportSpecifier {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        Some(self.name.clone())
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = name;
    }
}

impl HasIsTypeOnlyInterface for ExportSpecifier {
    fn is_type_only(&self) -> bool {
        self.is_type_only
    }
}

#[derive(Debug)]
#[ast_type]
pub struct ExportAssignment {
    _node: BaseNode,
    pub is_export_equals: Option<bool>,
    pub expression: Rc<Node /*Expression*/>,
}

// TODO: should implement HasExpressionInterface for ExportAssignment?
impl ExportAssignment {
    pub fn new(base_node: BaseNode, is_export_equals: Option<bool>, expression: Rc<Node>) -> Self {
        Self {
            _node: base_node,
            is_export_equals,
            expression,
        }
    }
}

pub type CommentKind = SyntaxKind; /*SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia*/

pub struct CommentRange {
    pos: Cell<isize>,
    end: Cell<isize>,
    has_trailing_new_line: Option<bool>,
    kind: CommentKind,
}

impl CommentRange {
    pub fn new(
        kind: CommentKind,
        pos: isize,
        end: isize,
        has_trailing_new_line: Option<bool>,
    ) -> Self {
        Self {
            kind,
            pos: Cell::new(pos),
            end: Cell::new(end),
            has_trailing_new_line,
        }
    }
}

impl TextRange for CommentRange {
    fn pos(&self) -> isize {
        self.pos.get()
    }

    fn set_pos(&self, pos: isize) {
        self.pos.set(pos);
    }

    fn end(&self) -> isize {
        self.end.get()
    }

    fn set_end(&self, end: isize) {
        self.end.set(end);
    }
}

// TODO: should eg implement a CommentRangeInterface for CommentRange + SynthesizedComment?
#[derive(Debug)]
pub struct SynthesizedComment {
    has_trailing_new_line: Option<bool>,
    kind: CommentKind,
    text: String,
    has_leading_new_line: Option<bool>,
}

impl TextRange for SynthesizedComment {
    fn pos(&self) -> isize {
        -1
    }

    fn set_pos(&self, pos: isize) {
        panic!("Shouldn't call set_pos() on a SynthesizedComment")
    }

    fn end(&self) -> isize {
        -1
    }

    fn set_end(&self, end: isize) {
        panic!("Shouldn't call set_end() on a SynthesizedComment")
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocTypeExpression {
    _node: BaseNode,
    pub type_: Rc<Node /*TypeNode*/>,
}

impl JSDocTypeExpression {
    pub fn new(base_node: BaseNode, type_: Rc<Node>) -> Self {
        Self {
            _node: base_node,
            type_,
        }
    }
}

impl HasTypeInterface for JSDocTypeExpression {
    fn maybe_type(&self) -> Option<Rc<Node>> {
        Some(self.type_.clone())
    }

    fn set_type(&mut self, type_: Rc<Node>) {
        self.type_ = type_;
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocNameReference {
    _node: BaseNode,
    pub name: Rc<Node /*EntityName | JSDocMemberName*/>,
}

impl JSDocNameReference {
    pub fn new(base_node: BaseNode, name: Rc<Node>) -> Self {
        Self {
            _node: base_node,
            name,
        }
    }
}

impl NamedDeclarationInterface for JSDocNameReference {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        Some(self.name.clone())
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = name;
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocMemberName {
    _node: BaseNode,
    pub left: Rc<Node /*EntityName | JSDocMemberName*/>,
    pub right: Rc<Node /*Identifier*/>,
}

impl JSDocMemberName {
    pub fn new(base_node: BaseNode, left: Rc<Node>, right: Rc<Node>) -> Self {
        Self {
            _node: base_node,
            left,
            right,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct BaseJSDocUnaryType {
    _node: BaseNode,
    pub type_: Option<Rc<Node /*TypeNode*/>>,
}

impl BaseJSDocUnaryType {
    pub fn new(base_node: BaseNode, type_: Option<Rc<Node>>) -> Self {
        Self {
            _node: base_node,
            type_,
        }
    }
}

impl HasTypeInterface for BaseJSDocUnaryType {
    fn maybe_type(&self) -> Option<Rc<Node>> {
        self.type_.clone()
    }

    fn set_type(&mut self, type_: Rc<Node>) {
        self.type_ = Some(type_);
    }
}

#[derive(Debug)]
#[ast_type(
    interfaces = "NamedDeclarationInterface, HasTypeParametersInterface, GenericNamedDeclarationInterface, HasTypeInterface, SignatureDeclarationInterface"
)]
pub struct JSDocFunctionType {
    _signature_declaration: BaseSignatureDeclaration,
}

impl JSDocFunctionType {
    pub fn new(signature_declaration: BaseSignatureDeclaration) -> Self {
        Self {
            _signature_declaration: signature_declaration,
        }
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDoc {
    _node: BaseNode,
    pub tags: Option<NodeArray /*<JSDocTag>*/>,
    pub comment: Option<StringOrNodeArray /*<JSDocComment>*/>,
}

impl JSDoc {
    pub fn new(
        base_node: BaseNode,
        tags: Option<NodeArray>,
        comment: Option<StringOrNodeArray>,
    ) -> Self {
        Self {
            _node: base_node,
            tags,
            comment,
        }
    }
}

#[derive(Debug)]
#[ast_type(interfaces = "JSDocTagInterface")]
pub enum JSDocTag {
    BaseJSDocTag(BaseJSDocTag),
    JSDocAugmentsTag(JSDocAugmentsTag),
    JSDocImplementsTag(JSDocImplementsTag),
    BaseJSDocTypeLikeTag(BaseJSDocTypeLikeTag),
    JSDocTemplateTag(JSDocTemplateTag),
    JSDocSeeTag(JSDocSeeTag),
    JSDocTypedefTag(JSDocTypedefTag),
    JSDocCallbackTag(JSDocCallbackTag),
    JSDocPropertyLikeTag(JSDocPropertyLikeTag),
}

pub trait JSDocTagInterface {
    fn tag_name(&self) -> Rc<Node /*Identifier*/>;
    fn maybe_comment(&self) -> Option<&StringOrNodeArray /*<JSDocComment>*/>;
}

pub trait JSDocLinkLikeInterface {
    fn maybe_name(&self) -> Option<Rc<Node>>;
    fn text(&self) -> &str;
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocLink {
    _node: BaseNode,
    pub name: Option<Rc<Node /*EntityName | JSDocMemberName*/>>,
    pub text: String,
}

impl JSDocLink {
    pub fn new(base_node: BaseNode, name: Option<Rc<Node>>, text: String) -> Self {
        Self {
            _node: base_node,
            name,
            text,
        }
    }
}

impl JSDocLinkLikeInterface for JSDocLink {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        self.name.clone()
    }

    fn text(&self) -> &str {
        &self.text
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocLinkCode {
    _node: BaseNode,
    pub name: Option<Rc<Node /*EntityName | JSDocMemberName*/>>,
    pub text: String,
}

impl JSDocLinkCode {
    pub fn new(base_node: BaseNode, name: Option<Rc<Node>>, text: String) -> Self {
        Self {
            _node: base_node,
            name,
            text,
        }
    }
}

impl JSDocLinkLikeInterface for JSDocLinkCode {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        self.name.clone()
    }

    fn text(&self) -> &str {
        &self.text
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocLinkPlain {
    _node: BaseNode,
    pub name: Option<Rc<Node /*EntityName | JSDocMemberName*/>>,
    pub text: String,
}

impl JSDocLinkPlain {
    pub fn new(base_node: BaseNode, name: Option<Rc<Node>>, text: String) -> Self {
        Self {
            _node: base_node,
            name,
            text,
        }
    }
}

impl JSDocLinkLikeInterface for JSDocLinkPlain {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        self.name.clone()
    }

    fn text(&self) -> &str {
        &self.text
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocText {
    _node: BaseNode,
    pub text: String,
}

impl JSDocText {
    pub fn new(base_node: BaseNode, text: String) -> Self {
        Self {
            _node: base_node,
            text,
        }
    }
}

#[derive(Debug)]
pub enum StringOrNodeArray {
    String(String),
    NodeArray(NodeArray),
}

impl From<String> for StringOrNodeArray {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}

impl From<NodeArray> for StringOrNodeArray {
    fn from(value: NodeArray) -> Self {
        Self::NodeArray(value)
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag")]
pub struct BaseJSDocTag {
    _node: BaseNode,
    tag_name: Rc<Node /*Identifier*/>,
    comment: Option<StringOrNodeArray /*<JSDocComment>*/>,
}

impl BaseJSDocTag {
    pub fn new(
        base_node: BaseNode,
        tag_name: Rc<Node>,
        comment: Option<StringOrNodeArray>,
    ) -> Self {
        Self {
            _node: base_node,
            tag_name,
            comment,
        }
    }
}

impl JSDocTagInterface for BaseJSDocTag {
    fn tag_name(&self) -> Rc<Node> {
        self.tag_name.clone()
    }

    fn maybe_comment(&self) -> Option<&StringOrNodeArray> {
        self.comment.as_ref()
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocAugmentsTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub class: Rc<
        Node, /*ExpressionWithTypeArguments & { readonly expression: Identifier | PropertyAccessEntityNameExpression*/
    >,
}

impl JSDocAugmentsTag {
    pub fn new(base_jsdoc_tag: BaseJSDocTag, class: Rc<Node>) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            class,
        }
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocImplementsTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub class: Rc<
        Node, /*ExpressionWithTypeArguments & { readonly expression: Identifier | PropertyAccessEntityNameExpression*/
    >,
}

impl JSDocImplementsTag {
    pub fn new(base_jsdoc_tag: BaseJSDocTag, class: Rc<Node>) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            class,
        }
    }
}

pub trait JSDocTypeLikeTagInterface: JSDocTagInterface {
    fn maybe_type_expression(&self) -> Option<Rc<Node>>;
    fn type_expression(&self) -> Rc<Node>;
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct BaseJSDocTypeLikeTag {
    _base_jsdoc_tag: BaseJSDocTag,
    type_expression: Option<Rc<Node /*JSDocTypeExpression*/>>,
}

impl BaseJSDocTypeLikeTag {
    pub fn new(base_jsdoc_tag: BaseJSDocTag, type_expression: Option<Rc<Node>>) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            type_expression,
        }
    }
}

impl JSDocTypeLikeTagInterface for BaseJSDocTypeLikeTag {
    fn maybe_type_expression(&self) -> Option<Rc<Node>> {
        self.type_expression.clone()
    }

    fn type_expression(&self) -> Rc<Node> {
        self.type_expression.clone().unwrap()
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocTemplateTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub constraint: Option<Rc<Node /*JSDocTypeExpression*/>>,
    pub type_parameters: NodeArray, /*<TypeParameterDeclaration>*/
}

impl JSDocTemplateTag {
    pub fn new(
        base_jsdoc_tag: BaseJSDocTag,
        constraint: Option<Rc<Node>>,
        type_parameters: NodeArray,
    ) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            constraint,
            type_parameters,
        }
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocSeeTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub name: Option<Rc<Node /*JSDocNameReference*/>>,
}

impl JSDocSeeTag {
    pub fn new(base_jsdoc_tag: BaseJSDocTag, name: Option<Rc<Node>>) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            name,
        }
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocTypedefTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub full_name: Option<Rc<Node /*JSDocNamespaceDeclaration | Identifier*/>>,
    pub name: Option<Rc<Node /*Identifier*/>>,
    pub type_expression: Option<Rc<Node /*JSDocTypeExpression | JSDocTypeLiteral*/>>,
}

impl JSDocTypedefTag {
    pub fn new(
        base_jsdoc_tag: BaseJSDocTag,
        full_name: Option<Rc<Node>>,
        name: Option<Rc<Node>>,
        type_expression: Option<Rc<Node>>,
    ) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            full_name,
            name,
            type_expression,
        }
    }
}

impl NamedDeclarationInterface for JSDocTypedefTag {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        self.name.clone()
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone().unwrap()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = Some(name);
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocCallbackTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub full_name: Option<Rc<Node /*JSDocNamespaceDeclaration | Identifier*/>>,
    pub name: Option<Rc<Node /*Identifier*/>>,
    pub type_expression: Rc<Node /*JSDocSignature*/>,
}

impl JSDocCallbackTag {
    pub fn new(
        base_jsdoc_tag: BaseJSDocTag,
        type_expression: Rc<Node>,
        full_name: Option<Rc<Node>>,
        name: Option<Rc<Node>>,
    ) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            full_name,
            name,
            type_expression,
        }
    }
}

impl NamedDeclarationInterface for JSDocCallbackTag {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        self.name.clone()
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone().unwrap()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = Some(name);
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocSignature {
    _node: BaseNode,
    pub type_parameters: Option<NodeArray /*<JSDocTemplateTag>*/>,
    pub parameters: NodeArray, /*<JSDocParameterTag>*/
    pub type_: Option<Rc<Node /*JSDocReturnTag*/>>,
}

impl JSDocSignature {
    pub fn new(
        base_node: BaseNode,
        type_parameters: Option<NodeArray>,
        parameters: NodeArray,
        type_: Option<Rc<Node>>,
    ) -> Self {
        Self {
            _node: base_node,
            type_parameters,
            parameters,
            type_,
        }
    }
}

#[derive(Debug)]
#[ast_type(ancestors = "JSDocTag", interfaces = "JSDocTagInterface")]
pub struct JSDocPropertyLikeTag {
    _base_jsdoc_tag: BaseJSDocTag,
    pub name: Rc<Node /*EntityName*/>,
    pub type_expression: Option<Rc<Node /*JSDocTypeExpression*/>>,
    pub is_name_first: bool,
    pub is_bracketed: bool,
}

impl JSDocPropertyLikeTag {
    pub fn new(
        base_jsdoc_tag: BaseJSDocTag,
        type_expression: Option<Rc<Node>>,
        name: Rc<Node>,
        is_name_first: bool,
        is_bracketed: bool,
    ) -> Self {
        Self {
            _base_jsdoc_tag: base_jsdoc_tag,
            name,
            type_expression,
            is_name_first,
            is_bracketed,
        }
    }
}

impl NamedDeclarationInterface for JSDocPropertyLikeTag {
    fn maybe_name(&self) -> Option<Rc<Node>> {
        Some(self.name.clone())
    }

    fn name(&self) -> Rc<Node> {
        self.name.clone()
    }

    fn set_name(&mut self, name: Rc<Node>) {
        self.name = name;
    }
}

#[derive(Debug)]
#[ast_type]
pub struct JSDocTypeLiteral {
    _node: BaseNode,
    pub js_doc_property_tags: Option<NodeArray /*<JSDocPropertyLikeTag>*/>,
    pub is_array_type: bool,
}

impl JSDocTypeLiteral {
    pub fn new(
        base_node: BaseNode,
        js_doc_property_tags: Option<NodeArray>,
        is_array_type: bool,
    ) -> Self {
        Self {
            _node: base_node,
            js_doc_property_tags,
            is_array_type,
        }
    }
}

pub type FlowNode = ();
